/*
1.	В анонимном PL/SQL блоке распечатать все пифагоровы числа, меньшие 25 
(для печати использовать пакет dbms_output, процедуру put_line).
*/

DECLARE
  I_C INT;
  I_B INT;
  I_A INT;
BEGIN
  FOR I_C IN 1..25 LOOP
    FOR I_B IN 1..I_C LOOP
      FOR I_A IN 1..I_B LOOP
        IF (I_A * I_A + I_B * I_B = I_C * I_C) THEN
          DBMS_OUTPUT.PUT_LINE(I_A||', '||I_B||', '||I_C);
        END IF;
      END LOOP;
    END LOOP;
  END LOOP;  
END;

/*
2.	Переделать предыдущий пример, чтобы для определения, что 3 числа пифагоровы использовалась функция.
*/

DECLARE 
  I_C INT;
  I_B INT;
  I_A INT;

  FUNCTION NUMCHECK(
    A INT,
    B INT,
    C INT
  )
  RETURN BOOLEAN
  IS
    V_RESULT BOOLEAN;
  BEGIN
    IF (A*A+B*B=C*C) THEN
      V_RESULT:=TRUE;
    ELSE 
      V_RESULT:=FALSE;
    END IF;    
    RETURN V_RESULT;
  END; 
BEGIN 
  FOR I_C IN 1..25 LOOP
    FOR I_B IN 1..I_C LOOP
      FOR I_A IN 1..I_B LOOP
        IF NUMCHECK(I_A,I_B,I_C) = TRUE THEN
          DBMS_OUTPUT.PUT_LINE(I_A||', '||I_B||', '||I_C);
        END IF;
      END LOOP;
    END LOOP;
  END LOOP;  
END;

/*
3.	Написать хранимую процедуру, которой передается ID сотрудника и которая увеличивает ему зарплату на 10%, 
если в 2000 году у сотрудника были продажи. Использовать выборку количества заказов за 2000 год в переменную. 
А затем, если переменная больше 0, выполнить update данных.
*/

CREATE OR REPLACE PROCEDURE BONUS(ID_EMPLOYEE INTEGER) IS
  NUM INTEGER;
  
BEGIN
  SELECT COUNT(O.ORDER_ID) INTO NUM
    FROM ORDERS O
    WHERE ID_EMPLOYEE=O.SALES_REP_ID AND 
          DATE'2000-01-01' <= O.ORDER_DATE AND 
          O.ORDER_DATE < DATE'2001-01-01';
          
  IF NUM>0 THEN 
    UPDATE EMPLOYEES E
      SET E.SALARY = E.SALARY*1.1
      WHERE E.EMPLOYEE_ID = ID_EMPLOYEE;
  END IF;
END;

/*
4.	Проверить корректность данных о заказах, а именно, что поле ORDER_TOTAL равно сумме UNIT_PRICE * QUANTITY 
по позициям каждого заказа. Для этого создать хранимую процедуру, в которой будет в цикле for проход по всем 
заказам, далее по конкретному заказу отдельным select-запросом будет выбираться сумма по позициям данного 
заказа и сравниваться с ORDER_TOTAL. Для «некорректных» заказов распечатать код заказа, дату заказа, 
заказчика и менеджера.
*/

CREATE OR REPLACE PROCEDURE CHECKORDER
IS 
  v_SUMM NUMBER;
  v_DATE TIMESTAMP;
  v_CUSTOMER VARCHAR2(100);
  v_MANAGER VARCHAR2(100);

BEGIN
  FOR i_ORD IN (
    SELECT *
      FROM ORDERS
  ) LOOP
		SELECT SUM(OI.UNIT_PRICE*OI.QUANTITY) INTO v_SUMM
		  FROM ORDER_ITEMS OI
		  WHERE OI.ORDER_ID=i_ORD.ORDER_ID;
		IF i_ORD.ORDER_TOTAL<>v_SUMM THEN  
		  SELECT  C.CUST_FIRST_NAME || ' ' || C.CUST_LAST_NAME INTO v_CUSTOMER             
			FROM  CUSTOMERS C 
			where C.CUSTOMER_ID = i_ORD.CUSTOMER_ID;
			
		  SELECT  O.ORDER_DATE INTO v_DATE
			FROM  ORDERS O
			WHERE O.ORDER_ID = i_ORD.ORDER_ID;
			
		  SELECT E.FIRST_NAME || ' ' || E.LAST_NAME INTO v_MANAGER
			FROM ORDERS O INNER JOIN EMPLOYEES E ON O.SALES_REP_ID=E.EMPLOYEE_ID
			WHERE O.ORDER_ID = i_ORD.ORDER_ID;
		
		  DBMS_OUTPUT.PUT_LINE('КОД ЗАКАЗА: '||i_ORD.ORDER_ID||' ДАТА: '||v_DATE||' ЗАКАЗЧИК :'||v_CUSTOMER||' МЕНЕДЖЕР: '||v_MANAGER);
		END IF;
  END LOOP;
END;

/*
5.	Переписать предыдущее задание с использованием явного курсора.
*/

CREATE OR REPLACE PROCEDURE CHECKORDERCURSOR
AS
  CURSOR CURSOR_ORD IS
    SELECT O.ORDER_ID,
           O.ORDER_TOTAL,
           E.FIRST_NAME || ' ' || E.LAST_NAME AS EMPLOYEEFI,
           C.CUST_FIRST_NAME || ' ' || C.CUST_LAST_NAME AS CUSTOMERFI,          
           O.ORDER_DATE 
      FROM  ORDERS O INNER JOIN CUSTOMERS C ON O.CUSTOMER_ID=C.CUSTOMER_ID
            INNER JOIN EMPLOYEES E ON O.SALES_REP_ID=E.EMPLOYEE_ID;
  ORD_SUM NUMBER;
  
BEGIN    
   FOR ORD IN CURSOR_ORD 
   LOOP
		 SELECT SUM( OI.UNIT_PRICE*OI.QUANTITY )
			INTO ORD_SUM
			FROM ORDER_ITEMS OI
			WHERE OI.ORDER_ID=ORD.ORDER_ID;     
		  IF (ORD_SUM<>ORD.ORDER_TOTAL)
			THEN DBMS_OUTPUT.PUT_LINE('ID ЗАКАЗА: '||ORD.ORDER_ID||' ДАТА: '||ORD.ORDER_DATE||' ЗАКАЗЧИК :'||ORD.CUSTOMERFI||' МЕНЕДЖЕР: '||ORD.EMPLOYEEFI);
		  END IF;
    END LOOP;
END;

/*
6.	Написать функцию, в которой будет создан тестовый клиент, которому будет сделан заказ на текущую дату из 
одной позиции каждого товара на складе. Имя тестового клиента и ID склада передаются в качестве параметров. 
Функция возвращает ID созданного клиента.
*/

DECLARE
  v_IDCUSTOMER NUMBER;
  v_IDORDER NUMBER;
  v_LINEITEMID NUMBER;
  v_COUNTER NUMBER := 1;
  
FUNCTION ADDTOVAR(NAMECUSTOMER IN VARCHAR2, P_IDWAR IN NUMBER)
RETURN NUMBER
IS
  v_IDCUSTOMER NUMBER;
  CURSOR CUR_ID_TOVAR IS
    SELECT I.PRODUCT_ID, (
             SELECT PI.LIST_PRICE
               FROM  PRODUCT_INFORMATION PI
               WHERE  PI.PRODUCT_ID = I.PRODUCT_ID
           ) AS LIST_PRICE
    FROM WAREHOUSES W INNER JOIN INVENTORIES I ON W.WAREHOUSE_ID=I.WAREHOUSE_ID 
    WHERE W.WAREHOUSE_ID=P_IDWAR;
  
BEGIN
  INSERT INTO CUSTOMERS C(C.CUST_FIRST_NAME, C.CUST_LAST_NAME) 
    VALUES(NAMECUSTOMER, 'TEST')
    RETURNING CUSTOMER_ID INTO v_IDCUSTOMER;

  INSERT INTO ORDERS(CUSTOMER_ID, ORDER_DATE) 
    VALUES(v_IDCUSTOMER,SYSDATE)
    RETURNING ORDER_ID INTO v_IDORDER;
  
  FOR REC IN CUR_ID_TOVAR LOOP
    INSERT INTO ORDER_ITEMS(ORDER_ID,LINE_ITEM_ID, PRODUCT_ID,UNIT_PRICE,QUANTITY)  
      VALUES(v_IDORDER,v_COUNTER, REC.PRODUCT_ID,REC.LIST_PRICE,1);
      v_COUNTER :=v_COUNTER + 1;
   END LOOP;
    
  RETURN v_IDCUSTOMER;
END;


BEGIN
  DBMS_OUTPUT.ENABLE;
  DBMS_OUTPUT.PUT_LINE(ADDTOVAR('asdf',3));
END;


/*
7.	Добавить в предыдущую функцию проверку на существование склада с переданным ID. Для этого выбрать склад 
в переменную типа «запись о складе» и перехватить исключение no_data_found, если оно возникнет. В обработчике 
исключения выйти из функции, вернув null.
*/

DECLARE
  v_IDCUSTOMER NUMBER;
  v_IDORDER NUMBER;
  v_LINEITEMID NUMBER;
  v_COUNTER NUMBER := 1;
FUNCTION ADDTOVAR_EXCEPT(NAMECUSTOMER IN VARCHAR2, P_IDWAR IN NUMBER)
RETURN NUMBER
IS
  v_IDCUSTOMER NUMBER;
CURSOR ID_TOVAR IS
  SELECT I.PRODUCT_ID,(
          SELECT PI.LIST_PRICE
           FROM  PRODUCT_INFORMATION PI
           WHERE  PI.PRODUCT_ID = I.PRODUCT_ID
  ) AS LIST_PRICE
  FROM WAREHOUSES W INNER JOIN INVENTORIES I ON W.WAREHOUSE_ID=I.WAREHOUSE_ID 
  WHERE W.WAREHOUSE_ID=P_IDWAR;
  
  ROWWAREHOUSES  WAREHOUSES%ROWTYPE;
BEGIN
  BEGIN
    SELECT * INTO ROWWAREHOUSES
      FROM WAREHOUSES 
      WHERE WAREHOUSE_ID = P_IDWAR;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN 
      RETURN NULL;
  END;
  
  INSERT INTO CUSTOMERS C(C.CUST_FIRST_NAME, C.CUST_LAST_NAME) 
    VALUES(NAMECUSTOMER, 'TEST')
    RETURNING CUSTOMER_ID INTO v_IDCUSTOMER;

  INSERT INTO ORDERS(CUSTOMER_ID, ORDER_DATE) 
    VALUES(v_IDCUSTOMER,SYSDATE)
    RETURNING ORDER_ID INTO v_IDORDER;
  
  FOR REC IN ID_TOVAR LOOP
    INSERT INTO ORDER_ITEMS(ORDER_ID,LINE_ITEM_ID, PRODUCT_ID,UNIT_PRICE,QUANTITY)  
      VALUES(v_IDORDER,v_COUNTER, REC.PRODUCT_ID,REC.LIST_PRICE,1);
      v_COUNTER :=v_COUNTER + 1;
   END LOOP;
  
  RETURN v_IDCUSTOMER;
END;


BEGIN
  DBMS_OUTPUT.ENABLE;
  DBMS_OUTPUT.PUT_LINE(ADDTOVAR('asdf',3));
END;


/*
8.	Написанные процедуры и функции объединить в пакет FIRST_PACKAGE.
*/

CREATE OR REPLACE PACKAGE FIRST_PACKAGE AS
  FUNCTION NUMCHECK(A INTEGER,B INTEGER,C INTEGER) RETURN BOOLEAN;
  PROCEDURE BONUS(IDEMPLOYEE INTEGER);
  PROCEDURE CHECKORDER;
  PROCEDURE CHECKORDERCURSOR;
  FUNCTION ADDTOVAR(NAMECUSTOMER IN VARCHAR2, P_IDWAR IN NUMBER) RETURN NUMBER;
  FUNCTION ADDTOVARCURSOR(NAMECUSTOMER IN VARCHAR2, P_IDWAR IN NUMBER) RETURN NUMBER;
END;

CREATE OR REPLACE PACKAGE BODY FIRST_PACKAGE AS

  FUNCTION NUMCHECK(
    A INT,
    B INT,
    C INT
  )
  RETURN BOOLEAN
  IS
    V_RESULT BOOLEAN;
  BEGIN
    IF (A*A+B*B=C*C) THEN
      V_RESULT:=TRUE;
    ELSE 
      V_RESULT:=FALSE;
    END IF;    
    RETURN V_RESULT;
  END;

PROCEDURE BONUS(ID_EMPLOYEE INTEGER) IS
  NUM INTEGER;
  
BEGIN
  SELECT COUNT(O.ORDER_ID) INTO NUM
    FROM ORDERS O
    WHERE ID_EMPLOYEE=O.SALES_REP_ID AND 
          DATE'2000-01-01' <= O.ORDER_DATE AND 
          O.ORDER_DATE < DATE'2001-01-01';
          
  IF NUM>0 THEN 
    UPDATE EMPLOYEES E
      SET E.SALARY = E.SALARY*1.1
      WHERE E.EMPLOYEE_ID = ID_EMPLOYEE;
  END IF;
END;


PROCEDURE CHECKORDER
IS
  RESULT BOOLEAN;
  SUMMA NUMBER;
  DAT TIMESTAMP;
  CUSTOMER VARCHAR2(100);
  MANAG VARCHAR2(100);

BEGIN
  FOR REC IN (
    SELECT *
      FROM ORDERS
  ) LOOP
    SELECT SUM(UNIT_PRICE*QUANTITY) INTO SUMMA
      FROM ORDER_ITEMS 
      WHERE ORDER_ID=REC.ORDER_ID;
      
    IF REC.ORDER_TOTAL<>SUMMA THEN 
      SELECT C.CUST_FIRST_NAME || ' ' || C.CUST_LAST_NAME INTO CUSTOMER
        FROM ORDERS O INNER JOIN CUSTOMERS C ON O.CUSTOMER_ID = C.CUSTOMER_ID
        WHERE O.ORDER_ID = REC.ORDER_ID;
        
      SELECT E.FIRST_NAME || ' ' || E.LAST_NAME INTO MANAG
      FROM ORDERS O INNER JOIN EMPLOYEES E ON O.SALES_REP_ID=E.EMPLOYEE_ID
        WHERE O.ORDER_ID = REC.ORDER_ID;
    
     DBMS_OUTPUT.PUT_LINE('ID ЗАКАЗА: '||REC.ORDER_ID||' ДАТА: '||DAT||' ЗАКАЗЧИК :'||CUSTOMER||' МЭНЕДЖЕР: '||MANAG);
    END IF;
  END LOOP;
END;


PROCEDURE CHECKORDERCURSOR
AS
  CURSOR CURSOR_ORD IS
    SELECT O.ORDER_ID,
           O.ORDER_TOTAL,
           E.FIRST_NAME || ' ' || E.LAST_NAME AS EMPLOYEEFI,
           C.CUST_FIRST_NAME || ' ' || C.CUST_LAST_NAME AS CUSTOMERFI,          
           O.ORDER_DATE 
      FROM  ORDERS O INNER JOIN CUSTOMERS C ON O.CUSTOMER_ID=C.CUSTOMER_ID
            INNER JOIN EMPLOYEES E ON O.SALES_REP_ID=E.EMPLOYEE_ID;
  ORD_SUM NUMBER;
  
BEGIN    
   FOR ORD IN CURSOR_ORD 
   LOOP
     SELECT SUM( OI.UNIT_PRICE*OI.QUANTITY )
        INTO ORD_SUM
        FROM ORDER_ITEMS OI
        WHERE OI.ORDER_ID=ORD.ORDER_ID;     
      IF (ORD_SUM<>ORD.ORDER_TOTAL)
        THEN DBMS_OUTPUT.PUT_LINE('ID ЗАКАЗА: '||ORD.ORDER_ID||' ДАТА: '||ORD.ORDER_DATE||' ЗАКАЗЧИК :'||ORD.CUSTOMERFI||' МЭНЕДЖЕР: '||ORD.EMPLOYEEFI);
      END IF;
    END LOOP;
END;



FUNCTION ADDTOVAR(NAMECUSTOMER IN VARCHAR2, P_IDWAR IN NUMBER)
RETURN NUMBER
IS
  v_IDCUSTOMER NUMBER;
CURSOR ID_TOVAR IS
  SELECT I.PRODUCT_ID,(
          SELECT PI.LIST_PRICE
           FROM  PRODUCT_INFORMATION PI
           WHERE  PI.PRODUCT_ID = I.PRODUCT_ID
  ) AS LIST_PRICE
  FROM WAREHOUSES W INNER JOIN INVENTORIES I ON W.WAREHOUSE_ID=I.WAREHOUSE_ID 
  WHERE W.WAREHOUSE_ID=P_IDWAR;
  
BEGIN
  INSERT INTO CUSTOMERS C(C.CUST_FIRST_NAME, C.CUST_LAST_NAME) 
    VALUES(NAMECUSTOMER, 'TEST')
    RETURNING CUSTOMER_ID INTO v_IDCUSTOMER;

  INSERT INTO ORDERS(CUSTOMER_ID, ORDER_DATE) 
    VALUES(v_IDCUSTOMER,SYSDATE)
    RETURNING ORDER_ID INTO v_IDORDER;
  
  FOR REC IN ID_TOVAR LOOP
    INSERT INTO ORDER_ITEMS(ORDER_ID,LINE_ITEM_ID, PRODUCT_ID,UNIT_PRICE,QUANTITY)  
      VALUES(v_IDORDER,v_COUNTER, REC.PRODUCT_ID,REC.LIST_PRICE,1);
      v_COUNTER :=v_COUNTER + 1;
   END LOOP;

  RETURN v_IDCUSTOMER;
END;


FUNCTION ADDTOVAR_EXCEPT(NAMECUSTOMER IN VARCHAR2, P_IDWAR IN NUMBER)
RETURN NUMBER
IS
  v_IDCUSTOMER NUMBER;
CURSOR ID_TOVAR IS
  SELECT I.PRODUCT_ID,(
          SELECT PI.LIST_PRICE
           FROM  PRODUCT_INFORMATION PI
           WHERE  PI.PRODUCT_ID = I.PRODUCT_ID
  ) AS LIST_PRICE
  FROM WAREHOUSES W INNER JOIN INVENTORIES I ON W.WAREHOUSE_ID=I.WAREHOUSE_ID 
  WHERE W.WAREHOUSE_ID=P_IDWAR;
  
  ROWWAREHOUSES  WAREHOUSES%ROWTYPE;
BEGIN
  BEGIN
    SELECT * INTO ROWWAREHOUSES
      FROM WAREHOUSES 
      WHERE WAREHOUSE_ID = P_IDWAR;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN 
      RETURN NULL;
  END;
  
  INSERT INTO CUSTOMERS C(C.CUST_FIRST_NAME, C.CUST_LAST_NAME) 
    VALUES(NAMECUSTOMER, 'TEST')
    RETURNING CUSTOMER_ID INTO v_IDCUSTOMER;

  INSERT INTO ORDERS(CUSTOMER_ID, ORDER_DATE) 
    VALUES(v_IDCUSTOMER,SYSDATE)
    RETURNING ORDER_ID INTO v_IDORDER;
  
  FOR REC IN ID_TOVAR LOOP
    INSERT INTO ORDER_ITEMS(ORDER_ID,LINE_ITEM_ID, PRODUCT_ID,UNIT_PRICE,QUANTITY)  
      VALUES(v_IDORDER,v_COUNTER, REC.PRODUCT_ID,REC.LIST_PRICE,1);
      v_COUNTER :=v_COUNTER + 1;
   END LOOP;
    
  RETURN v_IDCUSTOMER;
END;

/* сейчас он не работает, нужно переписать*/
/*
9.	Написать функцию, которая возвратит таблицу (table of record), содержащую информацию о частоте встречаемости 
отдельных символов во всех названиях (и описаниях) товара на заданном языке (передается код языка, а также 
параметр, указывающий, учитывать ли описания товаров). Возвращаемая таблица состоит из 2-х полей: символ, 
частота встречаемости в виде частного от кол-ва данного символа к количеству всех символов в названиях 
(и описаниях) товара.
*/

--SET SERVEROUTPUT ON
-- select user from dual;

DECLARE

TYPE T_ROW IS RECORD (SIMVOL NCHAR(1), COL NUMBER);
TYPE T_TABLE0 IS TABLE OF T_ROW;
TYPE T_TABLE IS TABLE OF T_ROW INDEX BY BINARY_INTEGER;

V_TAB T_TABLE;

  FUNCTION COUNTCHARS(IDLANG IN VARCHAR2, P_DESCRIPTION BOOLEAN)
  RETURN T_TABLE
  IS
    CURSOR TOVAR IS
      SELECT TRANSLATED_NAME, TRANSLATED_DESCRIPTION
      FROM PRODUCT_DESCRIPTIONS
      WHERE LANGUAGE_ID=IDLANG;
      
    V_COUNT NUMBER := 0;
    V_CODE NUMBER := 0;
    V_TABLE T_TABLE;
  BEGIN  
    FOR IND IN 0..255 LOOP
      V_TABLE(IND).COL := 0;
    END LOOP;
 
    FOR V_LINE IN TOVAR LOOP
      --DBMS_OUTPUT.PUT_LINE(V_LINE.TRANSLATED_NAME);
      V_COUNT := V_COUNT + LENGTH(V_LINE.TRANSLATED_NAME);
      
      FOR IND IN 1..LENGTH(V_LINE.TRANSLATED_NAME) LOOP
        V_CODE := ASCII(SUBSTR(V_LINE.TRANSLATED_NAME,IND,1));
        --DBMS_OUTPUT.PUT_LINE(V_CODE);
        V_TABLE(V_CODE).COL:= V_TABLE(V_CODE).COL + 1;
      END LOOP;
      
      --СЧИТАЕМ ОПИСАНИЕ
      IF P_DESCRIPTION THEN
        V_COUNT := V_COUNT + LENGTH(V_LINE.TRANSLATED_DESCRIPTION);
        
        FOR IND IN 1..LENGTH(V_LINE.TRANSLATED_DESCRIPTION) LOOP
          V_CODE := ASCII(SUBSTR(V_LINE.TRANSLATED_DESCRIPTION,IND,1));
          --DBMS_OUTPUT.PUT_LINE(V_CODE);
          V_TABLE(V_CODE).COL:= V_TABLE(V_CODE).COL + 1;
        END LOOP;
      END IF;
    END LOOP;
        
    FOR IND IN 0..255 LOOP
      V_TABLE(IND).SIMVOL := CHR(IND);
    END LOOP;
    
    RETURN V_TABLE;
  END;

BEGIN
  DBMS_OUTPUT.ENABLE;
  V_TAB := COUNTCHARS('US',TRUE);
  
  FOR IND IN 0..255 LOOP
    IF V_TAB(IND).COL>0 THEN
      DBMS_OUTPUT.PUT_LINE(V_TAB(IND).SIMVOL || ' ' || V_TAB(IND).COL);
    END IF;
  END LOOP;
END;


/*
10.	Написать функцию, которой передается sys_refcursor и которая по данному курсору формирует HTML-таблицу, 
содержащую информацию из курсора. Тип возвращаемого значения – clob.
*/

DECLARE
V_CURS SYS_REFCURSOR;

  FUNCTION TABLEHTML(P_CUR IN SYS_REFCURSOR)
  RETURN CLOB
  IS
    RES CLOB;    
    V_CUR SYS_REFCURSOR  := P_CUR;
    V_CN INTEGER;  
    V_COLS_DESC DBMS_SQL.DESC_TAB2;  
    V_COLS_COUNT INTEGER;
    
    V_STR VARCHAR2(500);
    V_ROW VARCHAR2(500);
  BEGIN
    RES:='<TABLE>';
    
    V_CN := DBMS_SQL.TO_CURSOR_NUMBER(V_CUR); 
    DBMS_SQL.DESCRIBE_COLUMNS2(V_CN, V_COLS_COUNT, V_COLS_DESC); 
    
    FOR I_INDEX IN 1..V_COLS_COUNT LOOP
      DBMS_SQL.DEFINE_COLUMN(V_CN, I_INDEX, V_STR, 500); 
    END LOOP;
    
    WHILE DBMS_SQL.FETCH_ROWS(V_CN)>0 LOOP      
      V_ROW:='<TR>';
      FOR I_INDEX IN 1..V_COLS_COUNT LOOP
        DBMS_SQL.COLUMN_VALUE(V_CN, I_INDEX, V_STR);
        V_ROW := V_ROW || '<TH>' || V_STR || '</TR>';
      END LOOP;
      V_ROW:=V_ROW || '</TR>';
      RES:=RES || V_ROW;
    END LOOP;
    
    DBMS_SQL.CLOSE_CURSOR(V_CN);
    
    RES:=RES || '</TABLE>';
  RETURN RES;
  END;

BEGIN
  DBMS_OUTPUT.ENABLE;
  OPEN V_CURS FOR SELECT * FROM COUNTRIES;
  DBMS_OUTPUT.PUT_LINE(TABLEHTML(V_CURS));
END;




















